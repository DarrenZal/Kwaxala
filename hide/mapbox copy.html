<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Globe Viewer - Mapbox GL JS</title>
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.js"></script>
    <link
      href="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.css"
      rel="stylesheet"
    />
    <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v4.7.0/mapbox-gl-geocoder.min.js"></script>
    <link
      rel="stylesheet"
      href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v4.7.0/mapbox-gl-geocoder.css"
      type="text/css"
    />
    <script src="https://unpkg.com/@mapbox/togeojson@0.16.0/togeojson.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exif-js/2.3.0/exif.js"></script>
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        font-family: Arial, sans-serif;
        height: 100%;
        overflow: hidden;
      }
      #map {
        width: 100%;
        height: 100%;
      }
      .search-container {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 1;
        width: 300px;
      }
      .mapboxgl-ctrl-geocoder {
        width: 100%;
        max-width: none;
        box-shadow: 0 0 10px 2px rgba(0, 0, 0, 0.1);
      }
      .custom-map-control {
        background-color: #fff;
        border: none;
        cursor: pointer;
        padding: 6px;
        border-radius: 4px;
        box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1);
        margin-bottom: 5px;
      }
      .custom-map-control:hover {
        background-color: #f2f2f2;
      }
      #file-input {
        display: none;
      }
      .info-panel {
        position: absolute;
        bottom: 20px; /* Changed from top to bottom */
        right: 20px;
        width: 300px;
        background: white;
        padding: 15px;
        border-radius: 5px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        display: none;
        max-height: 50vh; /* Limit height to 50% of viewport height */
        overflow-y: auto; /* Add scrollbar if content exceeds max-height */
      }
      .kml-marker {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 120px; /* Adjust based on your needs */
      }
      .kml-icon {
        width: 30px;
        height: 30px;
        background-image: url("kwakiah-icon.png");
        background-size: cover;
        background-position: center;
        border-radius: 50%;
        border: 2px solid white;
        cursor: pointer;
        z-index: 2;
      }
      .kml-label {
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    margin-top: 5px;
    font-size: 14px;
    font-weight: bold;
    text-align: center;
    color: white;
    max-width: 100%;
    overflow-wrap: break-word;
    padding: 2px 4px;
    border-radius: 2px;
  }
      .mapboxgl-popup-content {
        padding: 10px;
        max-width: 200px;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <!-- <div class="search-container"> -->
      <div id="geocoder" class="geocoder"></div>
    </div>
    <div id="info-panel" class="info-panel"></div>

    <script type="module">
      import { MAPBOX_ACCESS_TOKEN } from "./config.js";

      mapboxgl.accessToken = MAPBOX_ACCESS_TOKEN;

      const map = new mapboxgl.Map({
        container: "map",
        style: "mapbox://styles/mapbox/satellite-v9",
        center: [-125, 50],
        zoom: 1.5,
        pitch: 0,
        bearing: 0,
        projection: "globe",
        attributionControl: false, // Disable the default attribution control
      });

      let spinEnabled = true;
      let spinningInterval;
      let initialCenterSet = false;

      function spinGlobe() {
        if (!spinEnabled) return;
        const currentCenter = map.getCenter();
        map.easeTo({
          center: [currentCenter.lng + 0.5, currentCenter.lat],
          duration: 250,
          easing: (t) => t,
        });
      }

      let geojsonData;
      let customGeocoder;

      // Define customLocalGeocoder globally
      function customLocalGeocoder(query) {
  const matches = [];
  if (geojsonData && geojsonData.features) {
    geojsonData.features.forEach((feature, index) => {
      const name = feature.properties.name;
      if (name.toLowerCase().includes(query.toLowerCase())) {
        const matchingFeature = {
          ...feature,
          id: `dataset-${index}`,
          place_name: name,
          center: getFeatureCenter(feature),
        };
        matches.push(matchingFeature);
      }
    });
  }
  return matches;
}

      // Define the function to initialize the custom geocoder
      function initializeCustomGeocoder() {
        customGeocoder = new MapboxGeocoder({
          accessToken: mapboxgl.accessToken,
          mapboxgl: mapboxgl,
          localGeocoder: customLocalGeocoder,
          localGeocoderOnly: true,
          zoom: 14,
          placeholder: "Search for datasets",
          marker: false,
          render: function (item) {
            return `<div class='geocoder-dropdown-item'>
                <span>${item.properties.name || item.place_name}</span>
              </div>`;
          },
        });

        customGeocoder.on("result", function (e) {
          const feature = e.result;
          console.log("Geocoder feature:", feature);
          zoomToFeature(feature);
          showInfoPanel(feature, 0);
        });

        // Append the geocoder to the DOM
        document
          .getElementById("geocoder")
          .appendChild(customGeocoder.onAdd(map));
      }

      // Call initializeCustomGeocoder() at the top level
      initializeCustomGeocoder();

      // Define zoomToFeature function
      function zoomToFeature(feature) {
  const bounds = new mapboxgl.LngLatBounds();

  if (feature.geometry) {
    extendBounds(feature.geometry, bounds);
  }

  if (bounds.isEmpty() && feature.center) {
    console.log("Bounds are empty, using center point.");
    map.flyTo({ center: feature.center, zoom: 14, speed: 1.2 });
  } else if (!bounds.isEmpty()) {
    map.fitBounds(bounds, {
      padding: 50,
      maxZoom: 14,
      duration: 1000
    });
  } else {
    console.error("Cannot determine feature location.");
  }
}

      // Define showInfoPanel function
      function showInfoPanel(feature, index) {
        const infoPanel = document.getElementById("info-panel");
        infoPanel.style.display = "block";
        infoPanel.innerHTML = `
    <h3>${feature.properties.name || `Dataset ${index + 1}`}</h3>
    <p>${feature.properties.description || "Pacific Northwest."}</p>
    <p>Type: ${feature.geometry.type}</p>
    <!-- Add more properties as needed -->
  `;
      }

      // Custom 3D toggle control
      class ToggleMapControl {
        constructor() {
          this._map = null;
          this._container = null;
          this._toggleButton = null;
          this._toggleView = this._toggleView.bind(this);
        }

        onAdd(map) {
          this._map = map;
          this._container = document.createElement("div");
          this._container.className = "mapboxgl-ctrl mapboxgl-ctrl-group";

          this._toggleButton = document.createElement("button");
          this._toggleButton.className = "custom-map-control";
          this._toggleButton.textContent = "3D";

          this._container.appendChild(this._toggleButton);

          this._toggleButton.addEventListener("click", this._toggleView);

          return this._container;
        }

        onRemove() {
          this._container.removeChild(this._toggleButton);
          this._container.parentNode.removeChild(this._container);
          this._map = undefined;
        }

        _toggleView() {
          const is3D = this._map.getPitch() !== 0;
          this._map.easeTo({
            pitch: is3D ? 0 : 60,
            duration: 1000,
          });
          this._toggleButton.textContent = is3D ? "3D" : "2D";
        }
      }

      // Enable terrain for 3D effect
      map.on("style.load", () => {
        map.addSource("mapbox-dem", {
          type: "raster-dem",
          url: "mapbox://mapbox.mapbox-terrain-dem-v1",
          tileSize: 512,
          maxzoom: 14,
        });
        map.setTerrain({ source: "mapbox-dem", exaggeration: 1.5 });
      });

      const geojson = {
        type: "FeatureCollection",
        features: [
          {
            type: "Feature",
            geometry: {
              type: "Point",
              coordinates: [-123.1207, 49.2827],
            },
            properties: {
              title: "Vancouver",
              imageUrl: "https://example.com/vancouver.jpg",
            },
          },
          {
            type: "Feature",
            geometry: {
              type: "Point",
              coordinates: [-123.1216, 49.2827],
            },
            properties: {
              title: "Stanley Park",
              imageUrl: "https://example.com/stanley-park.jpg",
            },
          },
          // Add more features as needed
        ],
      };

      class PhotoUploadControl {
        constructor() {
          this._handleFileUpload = this._handleFileUpload.bind(this);
        }

        onAdd(map) {
          this._map = map;
          this._container = document.createElement("div");
          this._container.className = "mapboxgl-ctrl mapboxgl-ctrl-group";

          const fileInput = document.createElement("input");
          fileInput.type = "file";
          fileInput.id = "file-input";
          fileInput.accept = "image/*";
          fileInput.multiple = true;
          fileInput.style.display = "none";

          const button = document.createElement("button");
          button.className = "custom-map-control";
          button.style.fontSize = "20px";
          button.innerHTML = "ðŸ“·";

          this._container.appendChild(fileInput);
          this._container.appendChild(button);

          button.onclick = () => {
            fileInput.click();
          };

          fileInput.addEventListener("change", this._handleFileUpload);

          return this._container;
        }

        onRemove() {
          this._container.parentNode.removeChild(this._container);
          this._map = undefined;
        }

        _handleFileUpload(event) {
          const files = event.target.files;
          for (let i = 0; i < files.length; i++) {
            const file = files[i];
            const reader = new FileReader();

            reader.onload = (e) => {
              const img = new Image();
              img.src = e.target.result;

              img.onload = () => {
                EXIF.getData(img, () => {
                  const lat = EXIF.getTag(img, "GPSLatitude");
                  const lon = EXIF.getTag(img, "GPSLongitude");
                  const latRef = EXIF.getTag(img, "GPSLatitudeRef") || "N";
                  const lonRef = EXIF.getTag(img, "GPSLongitudeRef") || "W";
                  const direction = EXIF.getTag(img, "GPSImgDirection");

                  if (lat && lon) {
                    const latitude = this._convertDMSToDD(
                      lat[0],
                      lat[1],
                      lat[2],
                      latRef
                    );
                    const longitude = this._convertDMSToDD(
                      lon[0],
                      lon[1],
                      lon[2],
                      lonRef
                    );
                    this._addImageMarker(
                      latitude,
                      longitude,
                      file.name,
                      URL.createObjectURL(file),
                      direction
                    );
                  } else {
                    console.log("No GPS data found in the image.");
                  }
                });
              };
            };

            reader.readAsDataURL(file);
          }
        }

        _convertDMSToDD(degrees, minutes, seconds, direction) {
          let dd = degrees + minutes / 60 + seconds / (60 * 60);
          if (direction == "S" || direction == "W") {
            dd = dd * -1;
          }
          return dd;
        }

        _addImageMarker(lat, lon, title, imageUrl, direction) {
          const el = document.createElement("div");
          el.className = "marker";
          el.style.backgroundImage = "url(photo-icon.png)";
          el.style.width = "30px";
          el.style.height = "30px";
          el.style.backgroundSize = "100%";

          const popup = new mapboxgl.Popup({ offset: 25 }).setHTML(
            `<h3>${title}</h3><img src="${imageUrl}" alt="${title}" style="width:100%;">`
          );

          const marker = new mapboxgl.Marker(el)
            .setLngLat([lon, lat])
            .setPopup(popup)
            .addTo(this._map);

          marker.getElement().addEventListener("click", () => {
            this._map.easeTo({
              center: [lon, lat],
              zoom: 14,
              bearing: direction || 0,
              pitch: 60,
              duration: 2000,
            });
          });
        }
      }
      const kmlColors = {
  'TFL64.kml': '#FFD700', // bright yellow
  'TFL39B5.kml': '#ff0052'  // orange
};

      const kmlFiles = ['TFL64.kml', 'TFL39B5.kml'];

      async function processKMLFile(kmlUrl, color) {
  try {
    const response = await fetch(kmlUrl);
    const kmlData = await response.text();
    const parser = new DOMParser();
    const kml = parser.parseFromString(kmlData, "text/xml");
    const geojsonData = toGeoJSON.kml(kml);

    // Add color information to the properties
    geojsonData.features.forEach((feature) => {
      feature.properties.name = kmlUrl.replace('.kml', '');
      feature.properties.color = color;
    });

    return geojsonData;
  } catch (error) {
    console.error(`Error processing ${kmlUrl}:`, error);
    return null;
  }
}

      map.on("load", async function () {
  // Add atmosphere effect
  map.setFog({
    color: "rgb(186, 210, 235)",
    "high-color": "rgb(36, 92, 223)",
    "horizon-blend": 0.02,
    "space-color": "rgb(11, 11, 25)",
    "star-intensity": 0.6,
  });

  // Add custom controls
  map.addControl(new mapboxgl.NavigationControl(), "top-right");
  map.addControl(new mapboxgl.FullscreenControl(), "top-right");
  map.addControl(new ToggleMapControl(), "top-right");
  map.addControl(new PhotoUploadControl(), "top-right");

  // Process all KML files
  let allFeatures = [];
  const bounds = new mapboxgl.LngLatBounds();

  for (const kmlFile of kmlFiles) {
    const color = kmlColors[kmlFile];
    const geojsonData = await processKMLFile(kmlFile, color);
    
    if (geojsonData) {
      allFeatures = allFeatures.concat(geojsonData.features);
      
      const sourceId = `kml-data-${kmlFile}`;
      map.addSource(sourceId, {
        type: "geojson",
        data: geojsonData,
      });

      // Update polygon outlines layer with the specific color
      map.addLayer({
        id: `kml-polygon-outlines-${kmlFile}`,
        type: "line",
        source: sourceId,
        paint: {
          "line-color": color,
          "line-width": 2,
          "line-opacity": 0.8,
        },
        filter: ["==", ["geometry-type"], "Polygon"],
      });

      // Update lines layer with the specific color
      map.addLayer({
        id: `kml-lines-${kmlFile}`,
        type: "line",
        source: sourceId,
        paint: {
          "line-color": color,
          "line-width": 2,
          "line-opacity": 0.8,
        },
        filter: ["==", ["geometry-type"], "LineString"],
      });

      // Add markers with color-coordinated labels
      geojsonData.features.forEach((feature, index) => {
        const el = document.createElement("div");
        el.className = "kml-marker";

        const icon = document.createElement("div");
        icon.className = "kml-icon";

        const label = document.createElement("div");
        label.className = "kml-label";
        label.textContent = feature.properties.name;
        label.style.textShadow = `-1px -1px 0 ${color}, 1px -1px 0 ${color}, -1px 1px 0 ${color}, 1px 1px 0 ${color}`;

        el.appendChild(icon);
        el.appendChild(label);

        const marker = new mapboxgl.Marker({
          element: el,
          anchor: "bottom",
        })
          .setLngLat(getFeatureCenter(feature))
          .addTo(map);

        extendBounds(feature.geometry, bounds);

        // Add click handlers
        icon.addEventListener("click", () => {
          zoomToFeature(feature);
          showInfoPanel(feature, index);
        });

        label.addEventListener("click", () => {
          zoomToFeature(feature);
          showInfoPanel(feature, index);
        });
      });
    }
  }

  // Update the global geojsonData for the geocoder
  geojsonData = {
    type: "FeatureCollection",
    features: allFeatures
  };

  // Fit bounds if we have features
  if (!bounds.isEmpty()) {
    map.fitBounds(bounds, { padding: 50 });
  }

  // Start the spinning animation
  spinningInterval = setInterval(spinGlobe, 150);

  // Add event listeners to stop spinning on user interaction
  map.on("mousedown", stopSpinning);
  map.on("touchstart", stopSpinning);
  map.on("dragstart", stopSpinning);
});
  
      function stopSpinning() {
        spinEnabled = false;
        clearInterval(spinningInterval);
      }

      function getFeatureCenter(feature) {
        const bounds = new mapboxgl.LngLatBounds();
        extendBounds(feature.geometry, bounds);
        return bounds.getCenter();
      }

      // Move this function outside of the fetch chain
      function extendBounds(geometry, bounds) {
  if (geometry.type === "Point") {
    bounds.extend(geometry.coordinates);
  } else if (geometry.type === "LineString" || geometry.type === "MultiPoint") {
    geometry.coordinates.forEach(coord => bounds.extend(coord));
  } else if (geometry.type === "Polygon" || geometry.type === "MultiLineString") {
    geometry.coordinates.forEach(ring => 
      ring.forEach(coord => bounds.extend(coord))
    );
  } else if (geometry.type === "MultiPolygon") {
    geometry.coordinates.forEach(polygon => 
      polygon.forEach(ring => 
        ring.forEach(coord => bounds.extend(coord))
      )
    );
  } else if (geometry.type === "GeometryCollection") {
    geometry.geometries.forEach(geom => extendBounds(geom, bounds));
  }
}


      // Add this event listener to check if the map has loaded properly
      map.on("styledata", function () {
        if (map.isStyleLoaded()) {
          console.log("Map style has loaded");
        }
      });

      // Add this to check for any errors during map loading
      map.on("error", function (e) {
        console.error("Map error:", e.error);
      });
    </script>
  </body>
</html>
